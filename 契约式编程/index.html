<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>契约式编程 - soluty</title><meta name=description content="在人类的社会活动中，契约一般是用于两方，一方（供应商）为另一方（客户）完成一些任务。每一方都期待从契约中获得利益，同时也要接受一些义务。 通常，一方视为义务的对另一方来说是权利。契约文档要清楚地写明双方的权利与义务。契约合同能保障双方的利益. 对客户来说， 合同规定了供应者提供的功能；对供应商来说，合同说明了如果约定的条件不满足，供应商有权利拒绝要完成规定的任务。
同样的情况应用在软件开发过程中, 函数的实现是供应商, 函数的调用者是客户, 而函数的文档则可以视为双方所订的契约. 文档中会有 参数以及返回值的描述,参数满足文档中描述的内容是函数调用方的义务.同样返回一些什么值以及放回的值满足的条件则是函数的义务. 这个其实就是契约式编程的思想.在有些编程语言比如d语言中,语法级别支持了契约式编程.它对这种常见情况添加了in, out代码块, d语言的函数实现如下:
return_type function_name(function_params) in { // in block } out (result) { // in block } body { // actual function block } 一般的防御式编程中,认为在函数中检查错误状况并且上报，是函数本身的义务。而在契约体制下，对于契约的检查并非义务，实际上是在履行权利。一个义务，一个权利，天地之别。
例如这段的代码, if (param == NULL) { ... } 函数中写这段代码意味着这个是函数的义务, 函数必须对每一个参数进行严格的检查并保证任何情况下都没问题,这个极大的添加了函数编写的复杂度, 而这段代码assert(dest != NULL)是检查契约，履行权利。如果条件不满足，那么错误在对方而不在我，我可以立刻“撕毁合同”， 罢工了事, 并且把锅明确的甩到函数调用方, 这可以极大的降低函数本身的编写复杂度。并且在多人合作的过程中, 出了bug定位和分锅也非常简单明确.
契约式编程的思想对于区分错误和异常非常有用, 不满足契约的情况就是异常情况, 其它的情况是错误, 比如一个整数除法的函数,
func div(x int, y int) int 如果契约中有写y不能等于0,则调用方传了0是调用方的责任, 如果没写, 调用方传0, 那么div函数可以返回一个错误而绝对不允许panic.
理论上,文档是自然语言编写而成,它当然可以表示所有的契约, 但是在实际软件的编写的过程中,函数的文档或者注释并没有强制的效果, 在一方违反契约时,并没有办法简单快速的找出违反了哪些契约.所以在实践的过程中有必要对常见的情况进行抽象."><meta name=author content><link href=https://soluty.cc/an-old-hope.min.css rel=stylesheet><link href=https://soluty.cc/style.css rel=stylesheet><link href=https://soluty.cc/custom.css rel=stylesheet><link rel=apple-touch-icon href=https://soluty.cc/apple-touch-icon.png><link rel=icon href=https://soluty.cc/favicon.ico><meta name=generator content="Hugo 0.119.0"><script>function setTheme(){if(window.matchMedia("(prefers-color-scheme: dark)").matches){document.body.classList.add("dark");return}const n=new Date,a=localStorage.getItem("date"),s=String(n.getMonth()+1)+"."+String(n.getDate()),o=n.getTime();let e,t;function i(){if(o>e&&o<t)return;document.body.classList.add("dark")}s!==a?(fetch("https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215").then(e=>e.json()).then(n=>{e=n.sunrise.split(":").map(Number),t=n.sunset.split(":").map(Number)}).catch(()=>{e=[7,0],t=[19,0]}).finally(()=>{e=n.setHours(e[0],e[1],0),t=n.setHours(t[0],t[1],0),i(),localStorage.setItem("sunrise",e),localStorage.setItem("sunset",t)}),localStorage.setItem("date",s)):(e=Number(localStorage.getItem("sunrise")),t=Number(localStorage.getItem("sunset")),i())}</script></head><body class=single><script>setTheme()</script><header class=header><nav class=nav><p class=logo><a href=https://soluty.cc/>soluty</a></p></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>契约式编程</h1><div class=post-meta>November 7, 2023</div></header><div class=post-content><p>在人类的社会活动中，契约一般是用于两方，一方（供应商）为另一方（客户）完成一些任务。每一方都期待从契约中获得利益，同时也要接受一些义务。
通常，一方视为义务的对另一方来说是权利。契约文档要清楚地写明双方的权利与义务。契约合同能保障双方的利益. 对客户来说，
合同规定了供应者提供的功能；对供应商来说，合同说明了如果约定的条件不满足，供应商有权利拒绝要完成规定的任务。</p><p>同样的情况应用在软件开发过程中, 函数的实现是供应商, 函数的调用者是客户, 而函数的文档则可以视为双方所订的契约. 文档中会有
参数以及返回值的描述,参数满足文档中描述的内容是函数调用方的义务.同样返回一些什么值以及放回的值满足的条件则是函数的义务.
这个其实就是契约式编程的思想.在有些编程语言比如d语言中,语法级别支持了契约式编程.它对这种常见情况添加了in, out代码块, d语言的函数实现如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>return_type</span> <span style=color:#a6e22e>function_name</span>(<span style=color:#a6e22e>function_params</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>// in block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>out</span> (<span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>// in block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>body</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>// actual function block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>一般的防御式编程中,认为在函数中检查错误状况并且上报，是函数本身的义务。而在契约体制下，对于契约的检查并非义务，实际上是在履行权利。一个义务，一个权利，天地之别。</p><p>例如这段的代码, <code>if (param == NULL) { ... }</code> 函数中写这段代码意味着这个是函数的义务,
函数必须对每一个参数进行严格的检查并保证任何情况下都没问题,这个极大的添加了函数编写的复杂度,
而这段代码<code>assert(dest != NULL)</code>是检查契约，履行权利。如果条件不满足，那么错误在对方而不在我，我可以立刻“撕毁合同”，
罢工了事, 并且把锅明确的甩到函数调用方, 这可以极大的降低函数本身的编写复杂度。并且在多人合作的过程中, 出了bug定位和分锅也非常简单明确.</p><p>契约式编程的思想对于区分错误和异常非常有用, 不满足契约的情况就是异常情况, 其它的情况是错误, 比如一个整数除法的函数,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>div</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p>如果契约中有写y不能等于0,则调用方传了0是调用方的责任, 如果没写, 调用方传0, 那么div函数可以返回一个错误而绝对不允许panic.</p><p>理论上,文档是自然语言编写而成,它当然可以表示所有的契约, 但是在实际软件的编写的过程中,函数的文档或者注释并没有强制的效果,
在一方违反契约时,并没有办法简单快速的找出违反了哪些契约.所以在实践的过程中有必要对常见的情况进行抽象.</p><p>一般而言,契约式编程包含3种检测, require代表检测参数满足的条件,一般在函数运行之前检测,
ensure代表检测返回值满足的条件,一般在函数返回前检测.invariant则是代表不变量, 一般函数运行前和运行后都检测.</p><p>有些语言通过库对契约式编程提供了一定的支持,如<a href=https://gitlab.com/karroffel/contracts>rust</a>.</p><p>golang中如果要实现契约式编程,由于golang的源码发布特性以及defer方法的存在, 我通过经常在单元测试中使用的断言库gomega实现了一个小小的package
<code>github.com/soluty/golib/contract</code>来满足golang中引入契约式编程的需求.</p><p>使用的情况如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>div</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>contract</span>.<span style=color:#a6e22e>Sign</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Expect</span>(<span style=color:#a6e22e>y</span>).<span style=color:#a6e22e>Should</span>(<span style=color:#a6e22e>BeNumerically</span>(<span style=color:#e6db74>&#34;&gt;&#34;</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Expect</span>(<span style=color:#a6e22e>x</span>).<span style=color:#a6e22e>Should</span>(<span style=color:#a6e22e>BeNumerically</span>(<span style=color:#e6db74>&#34;&gt;&#34;</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>Expect</span>(<span style=color:#a6e22e>r</span>).<span style=color:#a6e22e>Should</span>(<span style=color:#a6e22e>BeNumerically</span>(<span style=color:#e6db74>&#34;&gt;=&#34;</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>/</span><span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一般而言, contract.Sign 代码块位于函数最前面, 代表使用函数时签订的契约. defer是在函数退出是检测. 并且通过编译tag
contract来控制是否开启契约的检测.</p></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://soluty.cc/>soluty</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://soluty.cc/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>