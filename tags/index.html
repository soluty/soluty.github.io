<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Tags - soluty</title><meta name=description content><meta name=author content><link href=https://soluty.cc/an-old-hope.min.css rel=stylesheet><link href=https://soluty.cc/style.css rel=stylesheet><link href=https://soluty.cc/custom.css rel=stylesheet><link rel=apple-touch-icon href=https://soluty.cc/apple-touch-icon.png><link rel=icon href=https://soluty.cc/favicon.ico><meta name=generator content="Hugo 0.119.0"><link rel=alternate type=application/rss+xml href=https://soluty.cc/tags/index.xml title=soluty><script>function setTheme(){if(window.matchMedia("(prefers-color-scheme: dark)").matches){document.body.classList.add("dark");return}const n=new Date,a=localStorage.getItem("date"),s=String(n.getMonth()+1)+"."+String(n.getDate()),o=n.getTime();let e,t;function i(){if(o>e&&o<t)return;document.body.classList.add("dark")}s!==a?(fetch("https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215").then(e=>e.json()).then(n=>{e=n.sunrise.split(":").map(Number),t=n.sunset.split(":").map(Number)}).catch(()=>{e=[7,0],t=[19,0]}).finally(()=>{e=n.setHours(e[0],e[1],0),t=n.setHours(t[0],t[1],0),i(),localStorage.setItem("sunrise",e),localStorage.setItem("sunset",t)}),localStorage.setItem("date",s)):(e=Number(localStorage.getItem("sunrise")),t=Number(localStorage.getItem("sunset")),i())}</script></head><body class=list><script>setTheme()</script><header class=header><nav class=nav><p class=logo><a href=https://soluty.cc/>soluty</a></p></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>契约式编程</h2></header><section class=entry-content><p>在人类的社会活动中，契约一般是用于两方，一方（供应商）为另一方（客户）完成一些任务。每一方都期待从契约中获得利益，同时也要接受一些义务。 通常，一方视为义务的对另一方来说是权利。契约文档要清楚地写明双方的权利与义务。契约合同能保障双方的利益. 对客户来说， 合同规定了供应者提供的功能；对供应商来说，合同说明了如果约定的条件不满足，供应商有权利拒绝要完成规定的任务。
同样的情况应用在软件开发过程中, 函数的实现是供应商, 函数的调用者是客户, 而函数的文档则可以视为双方所订的契约. 文档中会有 参数以及返回值的描述,参数满足文档中描述的内容是函数调用方的义务.同样返回一些什么值以及放回的值满足的条件则是函数的义务. 这个其实就是契约式编程的思想.在有些编程语言比如d语言中,语法级别支持了契约式编程.它对这种常见情况添加了in, out代码块, d语言的函数实现如下:
return_type function_name(function_params) in { // in block } out (result) { // in block } body { // actual function block } 一般的防御式编程中,认为在函数中检查错误状况并且上报，是函数本身的义务。而在契约体制下，对于契约的检查并非义务，实际上是在履行权利。一个义务，一个权利，天地之别。
例如这段的代码, if (param == NULL) { ... } 函数中写这段代码意味着这个是函数的义务, 函数必须对每一个参数进行严格的检查并保证任何情况下都没问题,这个极大的添加了函数编写的复杂度, 而这段代码assert(dest != NULL)是检查契约，履行权利。如果条件不满足，那么错误在对方而不在我，我可以立刻“撕毁合同”， 罢工了事, 并且把锅明确的甩到函数调用方, 这可以极大的降低函数本身的编写复杂度。并且在多人合作的过程中, 出了bug定位和分锅也非常简单明确.
契约式编程的思想对于区分错误和异常非常有用, 不满足契约的情况就是异常情况, 其它的情况是错误, 比如一个整数除法的函数,
func div(x int, y int) int 如果契约中有写y不能等于0,则调用方传了0是调用方的责任, 如果没写, 调用方传0, 那么div函数可以返回一个错误而绝对不允许panic.
理论上,文档是自然语言编写而成,它当然可以表示所有的契约, 但是在实际软件的编写的过程中,函数的文档或者注释并没有强制的效果, 在一方违反契约时,并没有办法简单快速的找出违反了哪些契约.所以在实践的过程中有必要对常见的情况进行抽象....</p></section><footer class=entry-footer><time>November 7, 2023</time></footer><a class=entry-link href=https://soluty.cc/%E5%A5%91%E7%BA%A6%E5%BC%8F%E7%BC%96%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2>kui&amp;scui</h2></header><section class=entry-content><p>目前主流的电脑上的人机交互接口有cli(command line interface)和gui(graphic user interface).
一般认为cli主要是键盘来操作,而gui主要是鼠标来操作.对这两种主要的操作方式,操作系统都会提供一些便捷的操作,比如快捷键和鼠标手势.
我喜欢使用快捷键操作, 但是目前所有操作系统的快捷键都有几个硬伤.
kui(keyboard user interface)或者scui(short cut user interface)是我提出的一个概念,志在对快捷键的操作进行一定的规范以屏蔽 掉主流操作系统之间的差异.它的设计目标如下:
对最常用的快捷键操作进行定义 最小化记忆负担 快捷键之间没有冲突 快捷键使用自然 尽量只用主键盘区域,60%的键盘也能轻松使用 目前的快捷键体系存在的问题 快捷键十分有限,主要通过修饰键(ctrl, alt, meta)和一个字符a-z组成 快捷键十分容易冲突,有限的快捷键就必然导致快捷键的冲突, 一般而言, 管理软件的软件, 如窗口管理器或者terminal multiplexer, 又或者是shell等软件的快捷键可能会和它们内部软件的快捷键冲突,而让快捷键变得不可用. 记忆负担重,基本上快捷键多起来会发现记忆毫无规律和逻辑. 设计一套好用的kui所面临的问题 kui设计的过程中面临着很多的难点, 但是最主要的难点是键盘它本身的多样性,即使去掉那些奇怪的双手键盘那种,同样是ansi的键盘,也可能有不同的键位布局如colemak或者我现在在用的normal布局.这会使得对一个人而言按着很舒服的快捷键对另一个人按起来也就没那么舒服.还有一点是 人的手舒适指头有一定区别,不止有左利手和右利手这种,有些人的弱指如小指头一天打字久了会疼,而有些人食指打字久了会疼.
所以设计一个对所有情况下都适用的kui其实是一件很困难的事情. 假如放弃掉那些奇怪布局的键盘,使用目前绝大多数的ansi的键盘.复杂度稍微小了一些.
还有一点是按键冲突的存在,在gui中,一个软件中如果包含另一个软件,鼠标所点击的地方永远是最上层的软件做响应,这使得gui中很自然不会有按钮 穿透的问题,但是放到快捷键上,如果窗口管理器设置ctrl+a打开一个新窗口,此时焦点在终端,终端又设置了ctrl+a做别的事情, 那么则会 使得终端中的设置变的毫无用处,这对于终端多路复用器和shell也同样适用.
下面所有的kui的设计都是基于ansi键盘和常用布局.
kui中的软件分类 为了消除软件的快捷键冲突,我们需要对电脑中的软件进行分类,一种类型的软件使用一个按键作为快捷键的修饰,这样就解决了快捷键冲突的问题.
软件类型 功能键 窗口管理器 ctrl gui中普通软件(除了有vim模式的文本编辑器) alt 可以连接ssh管理终端的软件(主要包括终端,浏览器) ctrl+alt 终端多路复用器 alt cli中普通软件 ,或者无功能键 以上5种类型基本可以覆盖到所有机器的所有软件.不管是访问哪台机器.
vim的启示和不足 vim是一个非常经典的文本编辑器,可以认为它在cli时代其实提供了一个十分经典的kui,导致很多软件的模仿,一些软件会标榜自己是vim like的 keybinding. 甚至现在任意一个文本编辑器如果没有vim快捷键的插件,可以认为它不是一个成熟的文本编辑器.
vim快捷键最大的优点是其在普通模式下leader键的设计, 导致它可以有无数的快捷键选择,并且这些快捷键还是有一些助记.在现在的gui环境下, 绝大多数软件的按键如果是普通的可视字符的话,都是会将其直接输入到输入框,或者如果没有输入框,则按键无意义.它们都是可以利用ctrl或者alt键 组合一个字母键来作为快捷键. 有些只能接受一个快捷键按键,有些可以接受快捷键序列, 例如ctrl+a a这种属于按下一个快捷键ctrl+a,然后马上按下a. 这个时候ctrl+a可以认为是vim中的leader键. 或者叫做快捷键的前缀....</p></section><footer class=entry-footer><time>November 6, 2023</time></footer><a class=entry-link href=https://soluty.cc/kuiscui/></a></article><article class=post-entry><header class=entry-header><h2>在neovim中快速运行一小段代码(动态语言篇)</h2></header><section class=entry-content><p>在编程的过程中,如何检验一断逻辑或者一个函数是否按照预期的来运行,一般情况下都是通过编写单元测试来实现.这在一个稍微长期一点的项目中 是有较大收益的,但是有些情况下并不是很适用.例如,短期的外包项目,又或者是在一些游戏项目中,demo期间和上线之前,策划的需求变化会非常的 频繁,这个时候单元测试就显得有些鸡肋.这个时候如何运行一个大工程中的一小段逻辑,目前业界并无通用的方法.
编辑器插件 如果对于只用到了标准库的动态语言而言,这个还算是很简单的一件事情,核心的思想就是把光标选择到的代码切割出来,把它写到一个临时文件 中,然后运行这个临时文件,假如是bash脚本,则运行bash temp.sh, 如果是python脚本, 则运行python temp.py.通过这个原理,vscode和 neovim中都有插件来完成这个事情.
vscode中出名的插件是微软工程师编写的code_runner,neovim中我觉得不错的插件是sniprun
当前这些插件的缺陷 这些插件都有一些缺陷,他们对于运行某一个文件支持的还不错,而对于运行一小段代码支持的不太行,他们都没有提供好点的办法支持函数的 调用, 比如在python脚本中a函数调用了b函数,即使这两个函数在一个文件,如果我只用光标框起a函数,这两个插件默认这个b函数是不会被选择进文件的,运行起来毫无疑问会报错.
对写法非常灵活的动态语言而言,那些插件似乎也只能做成这样,但是这样的话它的适用情况很狭隘,基本只能用于学习编程语言,是没有办法 在实际的工程中使用来满足运行一段逻辑的需求的.
少即是多,限制代码的写法来解决上面提到的问题 我一般写bash脚本的时候都是一个文件就搞定了,并且文件中会用main作为主函数,并且在最后一行调用main函数.这样可以保证所有的逻辑都 写在某一个函数中.我发现这种写法天生就能搞定上面的a函数调用b函数的问题, 只需要把文件中最后一行main函数调用的地方给去掉, 然后把光标所选择的代码放置到文件的最后, 即可. 或者将这些代码放在一个特定名字的函数,如___main___中,然后调用这个 ___main___函数即可完美解决bash中运行光标所选代码的问题,光标运行的代码和在实际的文件中运行的代码的作用会完全一样.
这个思路无论对vscode或者是neovim或者其他的编辑器都是适用的.因为我现在写代码主要使用的编辑器是neovim,vscode主要用在网页上阅读github 上的开源代码而不用将其clone下来.所以我后面的具体实现上都以neovim的lua代码作为描述,vscode应该也能通过同样思路来实现.
还有一个情况,通常而言所有的语言虽然不是必须要格式化以后才能运行,但是对于运行一小段代码而言,一个通用的前提条件是整个工程的代码 都已经格式化过了, 这个在所有的编辑器中都很容易配置成自动完成,这也属于限制代码写法的一部分.
所以,对于解释性的脚本语言而言,如果我们限制所有代码必须写函数中并且会通过main函数作为唯一的入口来调用的话,那么 把光标所在文件的所有内容除去main函数调用的地方全部克隆过去并将光标所选择的代码拷贝到___main___函数中,并最后调用___main___ 函数是一个通用的做法,他能保证对于所有单文件脚本,不管它有没有调用外部库,都能够做到完美的运行大工程中的一小段代码.
bash 下面的代码是对bash脚本的实现, 通过line:match("^main$")来过滤掉main这一行调用,并且把选择的代码包裹进___main___函数中,然后调用.
local function createBashCodeString() local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false) local filtered_content = {} for _, line in ipairs(lines) do if line:match("^main$") then goto continue end table.insert(filtered_content, line) ::continue:: end table.insert(filtered_content, "___main___(){") local selectLines = util....</p></section><footer class=entry-footer><time>November 6, 2023</time></footer><a class=entry-link href=https://soluty.cc/%E5%9C%A8neovim%E4%B8%AD%E5%BF%AB%E9%80%9F%E8%BF%90%E8%A1%8C%E4%B8%80%E5%B0%8F%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E7%AF%87/></a></article><article class=post-entry><header class=entry-header><h2>如何搭建自己域名的go模块</h2></header><section class=entry-content><p>为什么不直接用github而需要搭建自己域名的go模块 从golang1.13以后，go mod基本上已经成为了go语言模块化的标准，越来越多的go项目都开始对go mod进行支持，及大的方便了go语言的应用开发以及代码共享。 有很多的开源项目都放在github上面做成go语言的模块，可以很方便的通过go get github.com/*/*来引用，但是还有一些情况下让我们没办法这样使用github来分享模块：
如果是不开源的公司项目，恐怕没法分享到github上去，一般50人左右的公司，内网搭建一个小型的git服务是最方便的。 即使是个人开源的项目，也不一定非要通过github开源，首先github在国内某些网络环境下访问龟速，比如长宽这种，我家里图便宜用长宽，在github上下包的速度都是10k起往下降，甚至一度会断掉，我最试过长下一个67m的picgo，花了我3个小时。 绑定在个人域名下的项目，个人有极大的控制权，万一某gayhub被强了，或者某些代码库发疯封了你的代码（参考nodejs left-pad事件），你可以很方便的重建而不影响你的代码使用的客户。 怎么做 其实很简单，只需要在和你的模块名同名的网页的html的head标签中加上下面一句话即可。
&lt;meta name="go-import" content="${mod} git ${modurl}">
例如我有一个日志模块soluty.cc/xlog，模块代码托管在gitee上，url为https://gitee.com/soluty/xlog。 那么就需要在页面https://soluty.cc/xlog的head标签中加上 &lt;meta name="go-import" content="soluty.cc/xlog git https://gitee.com/soluty/xlog">
一定要注意，你的页面必须为https的，不要用http，不要用http，不要用http。...</p></section><footer class=entry-footer><time>October 26, 2023</time></footer><a class=entry-link href=https://soluty.cc/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%9F%9F%E5%90%8D%E7%9A%84go%E6%A8%A1%E5%9D%97/></a></article><article class=post-entry><header class=entry-header><h2>整洁架构</h2></header><section class=entry-content><p>本文翻译自Bob大叔的The Clean Architecture
过去几年里，我们看到了一系列关于系统架构的想法。包括：
六变形架构 洋葱圈架构 Screaming-Architecture DCI(data, context, interaction) BCE(boundary, control, entity) 虽然这些架构在细节上都有些不同，但它们非常相似。它们都有同样的目标，那就是分离关注点。它们都是通过把软件分层来实现这种分离。每个架构都至少有一层用于业务规则，还有一层用于接口。
所有这些架构构建的系统都有以下特征：
独立于框架。架构不依赖已存在的功能丰富的框架。这使得你可以将这些框架作为工具，而不是让你的系统受这些框架的限制。 可测试。业务规则可以爱没有ui,数据库，web服务器或者其他外部元素的情况下进行测试。 独立于UI。UI可以很容易改变，而不需要改变系统的其他部分。例如，在不改变业务规则的情况下，一个Web的UI可以很容易被一个Console的UI替换。 独立于数据库。你可以使用Oracle或者SQL Server, 或者 Mongo, BigTable, CouchDB等等。你的业务规则不受数据库的约束。 独立于任何的外部机构。事实上你的业务规则不知道任何外界的情况。 本文顶部的图是试图将所有这些架构整合成一个可行的想法。
依赖规则 同心圆代表软件的不同领域。一般来说，越往里走，软件的层次越高。外圈是机制，内圈是策略。
使得这个架构发挥作用的首要规则是依赖规则。这个规则是源代码的依赖只能是外圈依赖内圈。内圈中的对象不能知道外圈中的任何信息。特别是，外圈中声明的任何名字不能被内圈中的代码提及，包括函数，类，变了或者其他 命名的软件实体。
同样的道理，外圈中使用的数据格式不应该在内圈中被使用，尤其是这些格式是通过外圈中的某些框架生成的时候。我们不希望任何外圈的东西能影响到内圈。
实体层 实体封装了企业范围的业务规则。一个实体是一个有方法的对象，也可以是一组数据结构和函数。只要实体可以被企业中的不同应用所使用即可。
如果没有企业，只是编写单一的应用程序，实体则是应用的业务对象。它们封装了最同样和高级的规则。当外部事物发生变化时，它们是最不可能改变的。例如，你不会期望这些对象受到页面导航或者安全之类的影响。 任何应用程序操作的变化都不应该影响实体层。
用例层 这一层的软件包含了应用的业务规则细节，它封装并实现了系统中所有的用例。这些用例协调实体之间数据的流动，并指导这些实体使用其业务规则来实现用例的目标。
我们不希望这一层的变化会影响到实体。我们同样不希望这一层会被外部变化如数据库，UI或任何通用框架的影响。这一层要与这些关注点隔离。
然而，我们确实希望应用程序操作的变化会影响用例层的软件。如果用例的细节发生变化，那么这一层的代码肯定会受到影响。
接口适配器层 这一层的软件是一组适配器，它将数据从实体和用例最方便的格式转换为某些外部机制（如数据库或者Web）最方便的格式。例如，在这一层，会整个包含GUI应用中的MVC结构。 Presenter，View和Controller都属于这一层。模型很可能只是一些数据结构测哦嗯控制器传递到用例层，然后从用例层传回到Presenter和View。
同样，在这一层，数据也会被从对实体和用例最方便的格式转换为对某些持久化框架也就是数据库最方便的格式。这一层的代码不应该知道数据库的任何细节。如果数据库是关系型数据库，那么所有的SQL都应该 限制在这一层，特别是这一层中与数据库有关的部分。
同样在这一层中也是其他适配器需要将数据从外部格式(例如外部服务)转化为实体和用例使用的内部格式的地方。
框架和驱动层 最外层一般有框架和工具组成，如数据库，Web框架等。一般在这一层中除了向内层交流的胶水代码以外你不会写太多代码。
这一层是所有细节所在的地方。Web是细节，数据库是细节。我们将这些东西放在最外层，它们不会对代码造成伤害。
只有四层吗？ 不是的，这些圆圈是示意。你可能发现你不只需要4层。没有任何规定说你有且仅有这4层。但是，依赖规则总是适用的。源码只能是外层依赖内层，随着你向内层移动，抽象程度会增加。最外圈是最低级的细节。 向内移动，软件越来越抽象，并且封装了更高级的策略。越往内则越通用。
如何跨越边界 在图的右下方是我们如何跨越圈层边界的一个例子。它显示了控制者和演示者与下一层的用例进行沟通。请注意控制的流程。它从控制器开始，经过用例，然后最终在演示器中执行。还请注意源代码的依赖关系。它们中的每一个都向内指向用例。
我们通常通过使用依赖反转原则来解决这个明显的矛盾。例如，在像Java这样的语言中，我们会安排接口和继承关系，使源代码的依赖关系在恰好的点上反对控制流过边界。
例如，考虑到用例需要调用演示器。然而，这个调用一定不能是直接的，因为那会违反依赖规则。外圈中的任何名字都不能被内圈所提及。所以我们让用例调用内圈中的一个接口（这里显示为用例输出端口），让外圈中的presenter实现它。
同样的技术用于跨越架构中的所有边界。我们利用动态多态的优势，创建与控制流相反的源代码依赖关系，这样无论控制流向哪个方向，我们都能符合依赖规则。
哪些数据可以跨越边界 通常情况下，跨越边界的数据是简单的数据结构。你可以使用基本数据结构或者简单的数据传输对象。或者数据可以是函数调用中的参数。你也可以将其打包成一个map或者将其组织成一个对象。重要的是，跨边界的数据必须是 孤立的，简单的数据结构。我们不希望偷懒传递实体或者数据库的行。我们不希望数据结构有任何的打破依赖规则的依赖关系。
例如，很多的数据库框架都会返回一个方便的便于响应后续查询的数据结构。我们可以把它叫做行结构。我们不希望跨边界传递行结构。这将打破依赖规则，因为他会迫使内圈知道一些外圈的事情。
所以当我们跨边界传递数据时，总是以对内圈方便的数据结构进行传递。
结论 遵循这些简单的规则并不难，而且会让你在今后的工作中省去很多麻烦。通过将软件分成不同的层，并遵守依赖规则，你将创建一个本质上可测试的系统，并且有着上面所有的好处。当系统中任何外部的部分变得过时， 如数据库或者web框架，你可以用最少的代码替换这些过时的元素。...</p></section><footer class=entry-footer><time>October 26, 2023</time></footer><a class=entry-link href=https://soluty.cc/%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84/></a></article><article class=post-entry><header class=entry-header><h2>systray</h2></header><section class=entry-content><p>该仓库是fork的项目github.com/getlantern/systray，由于那个项目有几个私有的函数，我在做go语言ui程序的时候需要用到，所以对其做了一些小小的改动。主要包括两点：
将私有的nativeLoop函数修改成公有的NativeLoop 将Quit函数中只能执行一次的限制去掉，这样可以反复退出， 配合wails则可以用go开发一个带有托盘功能的跨3大主流桌面平台的gui app. systray is a cross-platform Go library to place an icon and menu in the notification area.
Features Supported on Windows, macOS, and Linux Menu items can be checked and/or disabled Methods may be called from any Goroutine API func main() { systray.Run(onReady, onExit) } func onReady() { systray.SetIcon(icon.Data) systray.SetTitle("Awesome App") systray.SetTooltip("Pretty awesome超级棒") mQuit := systray.AddMenuItem("Quit", "Quit the whole app") // Sets the icon of a menu item....</p></section><footer class=entry-footer><time>October 17, 2020</time></footer><a class=entry-link href=https://soluty.cc/systray/></a></article><article class=post-entry><header class=entry-header><h2>viper-config</h2></header><section class=entry-content><p>介绍 使用viper的配置编写和读取小工具，映射一个大的Config对象, 简化viper读取配置的编写
安装 go install soluty.cc/viper-config
使用说明 假设在config目录中有一个config.go文件， 其中定义一个类型为Config如下
type Config struct{ A int B string } 那么在该目录中调用viper-config config -p ${package} 即可生成config_gen_Config.go
其它地方调用生成的Init方法即可。为了方便，也可以放在go:generate中调用。
wishlist 目前不能直接映射time.Time结构体 没有封装写方法 ...</p></section><footer class=entry-footer><time>May 12, 2019</time></footer><a class=entry-link href=https://soluty.cc/viper-config/></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://soluty.cc/>soluty</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://soluty.cc/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>