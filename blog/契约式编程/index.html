<!doctype html><html lang=zh-CN><head><meta charset=utf-8><title>契约式编程</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=author content="Soluty"><meta name=generator content="Hugo 0.119.0"><link rel=stylesheet href=http://soluty.cc/css/bootstrap.min.css><link rel=stylesheet href=http://soluty.cc/font-awesome/css/font-awesome.min.css><link href=http://soluty.cc/scss/style.min.css rel=stylesheet><link rel="shortcut icon" href=http://soluty.cc/images/favicon.png type=image/x-icon><link rel=icon href=http://soluty.cc/images/favicon.ico type=image/x-icon></head><body><nav class="navbar navbar-expand-lg site-navigation"><div class=container><a class=navbar-brand href=http://soluty.cc/><img src=http://soluty.cc/images/image.png alt=logo></a>
<button class="navbar-toggler collapsed" type=button data-toggle=collapse data-target=#sitenavbar>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button><div class="collapse navbar-collapse" id=sitenavbar><ul class="navbar-nav ml-auto main-nav"><li class=nav-item><a class=nav-link href=http://soluty.cc/>主页</a></li><li class=nav-item><a class=nav-link href=http://soluty.cc/about>关于</a></li><li class=nav-item><a class=nav-link href=http://soluty.cc/portfolio>项目</a></li><li class=nav-item><a class=nav-link href=http://soluty.cc/blog>博客</a></li><li class=nav-item><a class="nav-link btn btn-sm btn-primary btn-sm-rounded" href=http://soluty.cc/contact><span class=btn-area><span data-text=联系我>联系我</span></span></a></li></ul></div></div></nav><main><section class="site-blog details"><div class=container><div class="row justify-content-center"><div class=col-lg-8><article class=site-blog-details><p><span>November 7, 2023</span> by <span>Soluty</span></p><h2 class=blog-title>契约式编程</h2><img class=feature-image src=http://soluty.cc/images/blog/blank.jpg alt=blog-feature-image><p>在人类的社会活动中，契约一般是用于两方，一方（供应商）为另一方（客户）完成一些任务。每一方都期待从契约中获得利益，同时也要接受一些义务。
通常，一方视为义务的对另一方来说是权利。契约文档要清楚地写明双方的权利与义务。契约合同能保障双方的利益. 对客户来说，
合同规定了供应者提供的功能；对供应商来说，合同说明了如果约定的条件不满足，供应商有权利拒绝要完成规定的任务。</p><p>同样的情况应用在软件开发过程中, 函数的实现是供应商, 函数的调用者是客户, 而函数的文档则可以视为双方所订的契约. 文档中会有
参数以及返回值的描述,参数满足文档中描述的内容是函数调用方的义务.同样返回一些什么值以及放回的值满足的条件则是函数的义务.
这个其实就是契约式编程的思想.在有些编程语言比如d语言中,语法级别支持了契约式编程.它对这种常见情况添加了in, out代码块, d语言的函数实现如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>return_type</span> <span style=color:#a6e22e>function_name</span>(<span style=color:#a6e22e>function_params</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>// in block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>out</span> (<span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>// in block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>body</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>// actual function block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>一般的防御式编程中,认为在函数中检查错误状况并且上报，是函数本身的义务。而在契约体制下，对于契约的检查并非义务，实际上是在履行权利。一个义务，一个权利，天地之别。</p><p>例如这段的代码, <code>if (param == NULL) { ... }</code> 函数中写这段代码意味着这个是函数的义务,
函数必须对每一个参数进行严格的检查并保证任何情况下都没问题,这个极大的添加了函数编写的复杂度,
而这段代码<code>assert(dest != NULL)</code>是检查契约，履行权利。如果条件不满足，那么错误在对方而不在我，我可以立刻“撕毁合同”，
罢工了事, 并且把锅明确的甩到函数调用方, 这可以极大的降低函数本身的编写复杂度。并且在多人合作的过程中, 出了bug定位和分锅也非常简单明确.</p><p>契约式编程的思想对于区分错误和异常非常有用, 不满足契约的情况就是异常情况, 其它的情况是错误, 比如一个整数除法的函数,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>div</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p>如果契约中有写y不能等于0,则调用方传了0是调用方的责任, 如果没写, 调用方传0, 那么div函数可以返回一个错误而绝对不允许panic.</p><p>理论上,文档是自然语言编写而成,它当然可以表示所有的契约, 但是在实际软件的编写的过程中,函数的文档或者注释并没有强制的效果,
在一方违反契约时,并没有办法简单快速的找出违反了哪些契约.所以在实践的过程中有必要对常见的情况进行抽象.</p><p>一般而言,契约式编程包含3种检测, require代表检测参数满足的条件,一般在函数运行之前检测,
ensure代表检测返回值满足的条件,一般在函数返回前检测.invariant则是代表不变量, 一般函数运行前和运行后都检测.</p><p>有些语言通过库对契约式编程提供了一定的支持,如<a href=https://gitlab.com/karroffel/contracts>rust</a>.</p><p>golang中如果要实现契约式编程,由于golang的源码发布特性以及defer方法的存在, 我通过经常在单元测试中使用的断言库gomega实现了一个小小的package
<code>github.com/soluty/golib/contract</code>来满足golang中引入契约式编程的需求.</p><p>使用的情况如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>div</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>r</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>contract</span>.<span style=color:#a6e22e>Sign</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Expect</span>(<span style=color:#a6e22e>y</span>).<span style=color:#a6e22e>Should</span>(<span style=color:#a6e22e>BeNumerically</span>(<span style=color:#e6db74>&#34;&gt;&#34;</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Expect</span>(<span style=color:#a6e22e>x</span>).<span style=color:#a6e22e>Should</span>(<span style=color:#a6e22e>BeNumerically</span>(<span style=color:#e6db74>&#34;&gt;&#34;</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>           <span style=color:#a6e22e>Expect</span>(<span style=color:#a6e22e>r</span>).<span style=color:#a6e22e>Should</span>(<span style=color:#a6e22e>BeNumerically</span>(<span style=color:#e6db74>&#34;&gt;=&#34;</span>,<span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>/</span><span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一般而言, contract.Sign 代码块位于函数最前面, 代表使用函数时签订的契约. defer是在函数退出是检测. 并且通过编译tag
contract来控制是否开启契约的检测.</p></article></div></div></div></section></main><footer class=site-footer><div class=container><div class=row><div class=col-12><div class=site-footer-logo><a href=http://soluty.cc/><img src=http://soluty.cc/images/image.png alt=logo-footer></a></div></div><div class="col-lg-3 col-md-6"><div class=site-footer-widget><h5 class=site-footer-widget-title>联系方式</h5><p class=site-footer-widget-description><a href=tel:13366151144>13366151144</a><br><a href=mailto:soluty.lv@qq.com>soluty.lv@qq.com</a></p></div></div><div class="col-lg-2 col-md-6"><div class=site-footer-widget><h5 class=site-footer-widget-title>导航</h5><ul class=site-footer-widget-links><li><a href=http://soluty.cc/about>关于</a></li><li><a href=http://soluty.cc/portfolio>项目</a></li><li><a href=http://soluty.cc/blog>博客</a></li><li><a href=http://soluty.cc/contact>联系我</a></li></ul></div></div><div class="col-lg-2 col-md-6"><div class=site-footer-widget><h5 class=site-footer-widget-title>社交媒体</h5><ul class=site-footer-widget-links><li><a href=#>微信</a></li><li><a href=#>知乎</a></li></ul></div></div><div class="col-lg-3 col-md-6"><div class=site-footer-widget><h5 class=site-footer-widget-title>我能做:</h5><p class=site-footer-widget-description>竭尽所能为您的伟大创意提供完美solution</p></div></div><div class="col-lg-2 col-12"><a href=#top class=site-footer-widget-top><img src=http://soluty.cc/images/to-top.svg alt=back-to-top><p>返回</p></a></div><div class=col-12><div class=site-footer-copyright><p>© Copyright 2023 - All Rights Reserved by <a href=https://staticmania.com/ target=_blank>StaticMania</a></p></div></div></div></div></footer><script src=http://soluty.cc/js/vendor.min.js></script>
<script src=http://soluty.cc/js/script.min.js></script></body></html>